<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aura - AI Tutor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body scroll, let content scroll */
        }
        /* Custom scrollbar for chat area */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body class="h-screen flex items-center justify-center bg-gray-100">
    <div id="root" class="w-full h-full">
        <div class="flex items-center justify-center h-full bg-gray-100">
            <div class="text-center text-gray-600 text-lg">
                Loading Aura...
            </div>
        </div>
    </div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <script type="module">
        // No Firebase imports needed as chat history persistence is removed

        /**
         * MessageBox Component
         * Displays a custom message box instead of browser's alert/confirm.
         * @param {object} props - Component props.
         * @param {string} props.message - The message to display.
         * @param {function} props.onClose - Callback function when the message box is closed.
         */
        const MessageBox = ({ message, onClose }) => {
            const e = React.createElement;
            return e('div', { className: 'fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50' },
                e('div', { className: 'bg-white p-6 rounded-lg shadow-xl max-w-sm w-full text-center' },
                    e('p', { className: 'text-lg font-semibold mb-4' }, message),
                    e('button', {
                        onClick: onClose,
                        className: 'bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50'
                    }, 'OK')
                )
            );
        };

        /**
         * highlightCode Helper Function
         * Applies basic syntax highlighting to a code string.
         * @param {string} code - The code string to highlight.
         * @returns {Array<React.ReactNode>} An array of React elements with syntax highlighting.
         */
        const highlightCode = (code) => {
            const e = React.createElement;
            const highlightedParts = [];
            let lastIndex = 0;

            // Regex to find keywords, functions, comments, strings, and numbers
            const regex = /(function\s+\w+|const\s+\w+\s*=\s*\([^)]*\)\s*=>|let\s+\w+\s*=\s*\([^)]*\)\s*=>|var\s+\w+\s*=\s*\([^)]*\)\s*=>|(\w+)\s*\([^)]*\)|new\s+\w+|this|if|else|for|while|return|class|import|export|true|false|null|undefined|\/\/.*|\/\*[\s\S]*?\*\/|(["'`])(?:(?!\1)[^\\]|\\.)*\1|\b\d+(\.\d+)?\b)/g;

            let match;
            while ((match = regex.exec(code)) !== null) {
                // Add plain text before the match
                if (match.index > lastIndex) {
                    highlightedParts.push(e('span', { key: `plain-${lastIndex}`, className: 'text-gray-200' }, code.substring(lastIndex, match.index)));
                }

                const matchedText = match[0];
                let className = 'text-gray-200'; // Default color

                // Determine the class based on the matched content
                if (matchedText.startsWith('//') || matchedText.startsWith('/*')) {
                    className = 'text-gray-500'; // Comments
                } else if (matchedText.startsWith('"') || matchedText.startsWith("'") || matchedText.startsWith("`")) {
                    className = 'text-orange-300'; // Strings
                } else if (!isNaN(matchedText)) {
                    className = 'text-yellow-300'; // Numbers
                } else if (/\b(function|const|let|var)\s+\w+/.test(matchedText) || /\w+\s*\([^)]*\)/.test(matchedText)) {
                    className = 'text-blue-400'; // Functions/Method calls
                } else if (/\b(if|else|for|while|return|class|import|export|new|this|true|false|null|undefined)\b/.test(matchedText)) {
                    className = 'text-purple-400'; // Keywords
                }

                highlightedParts.push(e('span', { key: `highlight-${match.index}`, className: className }, matchedText));
                lastIndex = regex.lastIndex;
            }

            // Add any remaining plain text after the last match
            if (lastIndex < code.length) {
                highlightedParts.push(e('span', { key: `plain-end-${lastIndex}`, className: 'text-gray-200' }, code.substring(lastIndex)));
            }

            return highlightedParts;
        };

        /**
         * renderMessageContent Helper Function
         * Renders text content, parsing basic Markdown for code blocks, bold, italics, and lists.
         * @param {string} text - The raw text content to parse.
         * @returns {Array<React.ReactNode>} An array of React elements representing the parsed content.
         */
        const renderMessageContent = (text) => {
            const e = React.createElement;
            const parts = [];
            let currentText = text;

            // Regex for code blocks (```...```)
            const codeBlockRegex = /(```[\s\S]*?```)/g;
            let match;
            let lastIndex = 0;

            while ((match = codeBlockRegex.exec(currentText)) !== null) {
                // Add text before the code block
                if (match.index > lastIndex) {
                    parts.push(currentText.substring(lastIndex, match.index));
                }
                // Add the code block
                parts.push(match[0]);
                lastIndex = codeBlockRegex.lastIndex;
            }
            // Add any remaining text after the last code block
            if (lastIndex < currentText.length) {
                parts.push(currentText.substring(lastIndex));
            }

            return parts.map((part, partIndex) => {
                if (part.startsWith('```') && part.endsWith('```')) {
                    // Code block - apply syntax highlighting
                    const codeContent = part.substring(3, part.length - 3).trim();
                    return e('pre', { key: partIndex, className: 'bg-gray-800 text-green-400 p-4 rounded-lg overflow-x-auto my-2 font-mono text-sm' },
                        e('code', null, highlightCode(codeContent)) // Use highlightCode here
                    );
                } else {
                    // Process regular text for other Markdown elements
                    const lines = part.split('\n');
                    return lines.map((line, lineIndex) => {
                        // Handle lists
                        if (line.match(/^(\s*[-*]\s+)/)) { // Unordered list
                            const listItemContent = line.replace(/^(\s*[-*]\s+)/, '');
                            return e('li', { key: `${partIndex}-${lineIndex}`, className: 'ml-4 list-disc text-gray-800' },
                                renderInlineMarkdown(listItemContent)
                            );
                        } else if (line.match(/^(\s*\d+\.\s+)/)) { // Ordered list
                            const listItemContent = line.replace(/^(\s*\d+\.\s+)/, '');
                            return e('li', { key: `${partIndex}-${lineIndex}`, className: 'ml-4 list-decimal text-gray-800' },
                                renderInlineMarkdown(listItemContent)
                            );
                        } else {
                            // Render inline markdown for the line
                            return e('p', { key: `${partIndex}-${lineIndex}`, className: 'mb-1 text-gray-800' },
                                renderInlineMarkdown(line)
                            );
                        }
                    });
                }
            });
        };

        /**
         * renderInlineMarkdown Helper Function
         * Renders inline Markdown elements like bold, italic, and inline code.
         * @param {string} text - The raw text content to parse for inline markdown.
         * @returns {Array<React.ReactNode>} An array of React elements representing the parsed inline content.
         */
        const renderInlineMarkdown = (text) => {
            const e = React.createElement;
            // Regex to find inline code (`...`), bold (**...** or __...__), and italic (*...* or _..._)
            const inlineParts = text.split(/(`[^`]+`|\*\*[^*]+\*\*|__[^_]+__|\*[^**]+\*|_[^_]+_)/g);

            return inlineParts.map((inlinePart, inlineIndex) => {
                if (inlinePart.startsWith('`') && inlinePart.endsWith('`')) {
                    return e('code', { key: inlineIndex, className: 'bg-gray-700 text-yellow-300 px-1 py-0.5 rounded font-mono text-sm' },
                        inlinePart.substring(1, inlinePart.length - 1)
                    );
                } else if (inlinePart.startsWith('**') && inlinePart.endsWith('**')) {
                    return e('strong', { key: inlineIndex, className: 'font-bold' },
                        inlinePart.substring(2, inlinePart.length - 2)
                    );
                } else if (inlinePart.startsWith('__') && inlinePart.endsWith('__')) {
                    return e('strong', { key: inlineIndex, className: 'font-bold' },
                        inlinePart.substring(2, inlinePart.length - 2)
                    );
                } else if (inlinePart.startsWith('*') && inlinePart.endsWith('*')) {
                    return e('em', { key: inlineIndex, className: 'italic' },
                        inlinePart.substring(1, inlinePart.length - 1)
                    );
                } else if (inlinePart.startsWith('_') && inlinePart.endsWith('_')) {
                    return e('em', { key: inlineIndex, className: 'italic' },
                        inlinePart.substring(1, inlinePart.length - 1)
                    );
                } else {
                    return e('span', { key: inlineIndex }, inlinePart);
                }
            });
        };

        /**
         * Aura Component
         * Provides an interactive AI-powered chat tutor without chat history persistence.
         * It uses the Gemini 2.0 Flash model for generating AI responses.
         */
        const Aura = () => { // Renamed from AITutor to Aura
            const { useState, useEffect, useRef } = React;
            const [inputMessage, setInputMessage] = useState('');
            const [chatHistory, setChatHistory] = useState([]); // Chat history for current session only
            const [isLoading, setIsLoading] = useState(false);
            const messagesEndRef = useRef(null);

            // State for displaying custom message box
            const [messageBox, setMessageBox] = useState(null);
            const showMessageBox = (message) => {
                setMessageBox({ message, onClose: () => setMessageBox(null) });
            };

            // Scroll to the bottom of the chat window whenever messages update or loading state changes
            useEffect(() => {
                scrollToBottom();
            }, [chatHistory, isLoading]);

            const scrollToBottom = () => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            };

            // Handles sending a message to the AI tutor
            const handleSendMessage = async () => {
                if (inputMessage.trim() === '') return;

                const userMessage = {
                    text: inputMessage,
                    role: 'user',
                    timestamp: new Date().toISOString(), // Use local timestamp for display
                };

                // Add user message to local chat history
                setChatHistory(prev => [...prev, userMessage]);
                setInputMessage('');
                setIsLoading(true);

                try {
                    // Prepare the chat history for the LLM (Large Language Model) API call
                    // The LLM needs the conversation context to generate relevant responses
                    const llmChatHistory = [...chatHistory, userMessage].map(msg => ({ // Use updated history for LLM
                        role: msg.role,
                        parts: [{ text: msg.text }]
                    }));

                    const payload = {
                        contents: llmChatHistory,
                    };

                    const apiKey = "AIzaSyC7RhRo6crgugnFSiDQUD6-y0Xclp_YhDs"; // API key is automatically provided by Canvas at runtime
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    // Make the API call to the Gemini model
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json(); // Parse the JSON response

                    // Check if the AI response is valid and contains content
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const aiResponseText = result.candidates[0].content.parts[0].text;
                        const aiMessage = {
                            text: aiResponseText,
                            role: 'model',
                            timestamp: new Date().toISOString(), // Use local timestamp for display
                        };
                        // Add the AI's response to local chat history
                        setChatHistory(prev => [...prev, aiMessage]);
                    } else {
                        // Handle cases where the API response structure is unexpected
                        console.error("Unexpected API response structure:", result);
                        showMessageBox("Sorry, I couldn't get a response from Aura. Please try again.");
                    }
                } catch (error) {
                    // Catch and handle any errors during the process (network, API)
                    console.error("Error sending message or getting AI response:", error);
                    showMessageBox("There was an error communicating with Aura. Please check your network connection and try again.");
                } finally {
                    setIsLoading(false); // Reset loading state
                }
            };

            // Handles key presses in the input textarea (e.g., sending on Enter)
            const handleKeyPress = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) { // Send message on Enter, but allow Shift+Enter for new line
                    e.preventDefault(); // Prevent default Enter behavior (new line)
                    handleSendMessage();
                }
            };

            return React.createElement('div', { className: 'flex flex-col h-screen bg-gray-100 font-sans' },
                React.createElement('div', { className: 'flex-1 flex flex-col p-8 overflow-hidden' },
                    React.createElement('header', { className: 'mb-8 pb-4 border-b border-gray-300' },
                        React.createElement('h1', { className: 'text-4xl font-extrabold text-gray-900 leading-tight' }, 'Aura')
                    ),
                    React.createElement('div', { className: 'flex-1 overflow-auto bg-white p-6 rounded-2xl shadow-xl flex flex-col' },
                        React.createElement('div', { className: 'flex-1 p-6 overflow-y-auto custom-scrollbar' },
                            chatHistory.length === 0 ? (
                                React.createElement('div', { className: 'text-center text-gray-500 text-lg mt-20' }, 'Start a conversation with Aura! Ask me anything about code or concepts.')
                            ) : (
                                chatHistory.map((msg, index) =>
                                    React.createElement('div', {
                                        key: index, // Use index as key since IDs are not persistent
                                        className: `flex mb-4 ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`
                                    },
                                        React.createElement('div', {
                                            className: `max-w-3/4 p-4 rounded-xl shadow-md text-gray-800 ${msg.role === 'user' ? 'bg-blue-200 rounded-br-none' : 'bg-gray-200 rounded-bl-none'}`
                                        },
                                            React.createElement('div', { className: 'whitespace-pre-wrap' },
                                                renderMessageContent(msg.text)
                                            ),
                                            React.createElement('span', { className: 'block text-xs text-gray-500 mt-1 text-right' },
                                                new Date(msg.timestamp).toLocaleTimeString() // Format local timestamp
                                            )
                                        )
                                    )
                                )
                            ),
                            isLoading && (
                                React.createElement('div', { className: 'flex justify-start mb-4' },
                                    React.createElement('div', { className: 'max-w-3/4 p-4 rounded-xl shadow-md bg-gray-200 rounded-bl-none' },
                                        React.createElement('div', { className: 'flex items-center' },
                                            React.createElement('div', { className: 'animate-spin rounded-full h-4 w-4 border-b-2 border-gray-900 mr-2' }),
                                            React.createElement('span', { className: 'text-gray-700' }, 'Thinking...')
                                        )
                                    )
                                )
                            ),
                            React.createElement('div', { ref: messagesEndRef })
                        ),
                        React.createElement('div', { className: 'p-4 border-t border-gray-200 bg-white flex items-center rounded-b-xl' },
                            React.createElement('textarea', {
                                className: 'flex-1 p-3 border border-gray-300 rounded-lg resize-none focus:ring-2 focus:ring-blue-500 focus:border-transparent mr-3 text-base',
                                rows: '2',
                                placeholder: 'Ask Aura a question...',
                                value: inputMessage,
                                onChange: (e) => setInputMessage(e.target.value),
                                onKeyPress: handleKeyPress,
                                disabled: isLoading
                            }),
                            React.createElement('button', {
                                onClick: handleSendMessage,
                                className: 'bg-blue-600 text-white px-6 py-3 rounded-lg text-lg font-semibold hover:bg-blue-700 transition-colors duration-300 shadow-md disabled:opacity-50 disabled:cursor-not-allowed',
                                disabled: isLoading || inputMessage.trim() === ''
                            }, 'Send')
                        )
                    )
                ),
                messageBox && React.createElement(MessageBox, { message: messageBox.message, onClose: messageBox.onClose })
            );
        };

        // Render the Aura component into the root div
        window.onload = function() {
            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(React.createElement(Aura));
        };
    </script>
</body>
</html>
